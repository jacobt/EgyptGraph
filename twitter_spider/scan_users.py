#! /usr/bin/env python

#	Twitter scraping script. Takes a line-separated list of twitter usernames
#	and pulls down an arbitrary number of tweets from each profile. 
#	
#	To use this script, you will need:
#		- Tweepy
#		- a newline delimited list of usernames (username, e.g. as_te_li)
#		- a file called 'keys.py' containing the variable assignments
#			detailed below (application codes and account linking codes)
#
#	The Twitter API is rate limited, therefore trying to fetch statuses from
#	over 350 users within an hour will cause twitter to block for an hour.
#
#	Unicode posts break the file writing mechanism at the moment.
#
#	Usage: scan_users.py <username list> <tweet dump target path> <input seek-to line> 
#		arguments are optional.
#	

import sys
import signal
import tweepy
import fileinput
import time
import os
import codecs

# keeping the access key/access secret in a separate file
# so that each person running this script can easily use their
# own access keys generated by link_acct.py
# Your 'keys.py' file should look like this
#ACCESS_KEY = '284417887-quUxFooBarrandomstuffgoeshere9001'
#ACCESS_SECRET = 'moReRand0ml0ok1ngstUfF1nh3re838hhsh36'
#CONSUMER_KEY = 'mJ6vPoSPrseFBsE2noKg'
#CONSUMER_SECRET = 'oFxu6wKrWVLRvy2kHzVvPKpEhT9XuSrz6bcmcluDbw'

import keys

############################# CONTROL SIG SETUP ##############################

# Catch SIGINT. sys.exit() would get ignored by this script,
# possibly having something to do with HTTP libraries' exception
# handling, so os._exit() is used instead.
def signal_handler(signal, frame):
	print "SIGINT caught, exiting. (PID: %d)" % (os.getpid())
#	tweet_output_file.close()
	username_file_desc.close()
	os._exit(0)
signal.signal(signal.SIGINT, signal_handler)


############################# ARGUMENT PARSING ##############################
arg_count = 0
for arg in sys.argv:
	arg_count = arg_count + 1

# set username input file
if (arg_count == 2):
	username_file = sys.argv[1].strip()
else:
	username_file = "usernames.txt"

# set tweet output file
if (arg_count == 3):
	user_output_file = sys.argv[2].strip()
else:
	user_output_file = 0

# set lines in input file to skip (ghetto line seek)
if (arg_count == 4):
	skip_to = sys.argv[3].strip()
else:
	skip_to = 0
cur_line_no = 1

# protip for the user if they get it wrong
if (arg_count < 1 or arg_count > 4):
	print "\nUsage: %s <username_file (opt)> <tweet_dump_file (opt)> <skip#(opt)>" %(sys.argv[0])
	print "Default value for <username_file> is 'usernames.txt'"
	os._exit(1)

print "Using: username_file='%s' output_file='%s' seek-to-line=%s" % (username_file, user_output_file, skip_to)

############################# TWITTER AUTH #################################

# Handshaking with Twitter using the account whose access keys were provided
auth = tweepy.OAuthHandler(keys.CONSUMER_KEY, keys.CONSUMER_SECRET)
auth.set_access_token(keys.ACCESS_KEY, keys.ACCESS_SECRET)
api = tweepy.API(auth)

############################# FILE I/O SETUP ###############################

#set up output file if requested
if ( user_output_file != 0 ):
	try:
		#tweet_output_file = codecs.open(user_output_file, encoding='utf-8', mode='w')
		tweet_output_file = open(user_output_file, mode='w')
	except:
		print "Could not open specified output file to write, exiting."
		os._exit(1)

# attempt to set up to read from the username input file
try:	# username file descriptor
	username_file_desc = open(username_file, 'r')
except:
	print "Could not open username file, exiting."
	os._exit(1)


############################# TWEET FETCHING ###############################

# the actual scanning of each user's status' happens here.
for scan_target in username_file_desc:
	if( cur_line_no > skip_to ):
		username = scan_target.strip()

		try:
			# pulls down [count] tweets, 
			user_statuses = api.user_timeline(username, count=3200)
		
			for status in user_statuses:
				cur_tweet = "At %s, %s said: %s" % (status.created_at, username, status.text)

			# write to file specified, else print to screen.
				if ( user_output_file != 0 ):
					try:	# to unicode and back to utf-8
						tweet_output_file.write(cur_tweet)
					except:
						print "Huh? Could not write to tweet output file."

				print cur_tweet

		except:
			print "Oops, %s's posts are unavailable." % (username)

		# used for seek-to-line
		cur_line_no = cur_line_no + 1

		# this value was chosen to correspond to a maximum request rate of 350/hour
		# if 350 requests happen, twitter stops responding. Hence 11 second delay.
		time.sleep(11.0)




############################# END OF PROGRAM ############################






