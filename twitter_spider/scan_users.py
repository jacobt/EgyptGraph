#! /usr/bin/env python

import sys
import signal
import tweepy
import fileinput
import time
import os
import codecs

# keeping the access key/access secret in a separate file
# so that each person running this script can easily use their
# own access keys generated by link_acct.py
# Your 'access.py' file should look like this
#ACCESS_KEY = '284417887-quUxFooBarrandomstuffgoeshere9001'
#ACCESS_SECRET = 'moReRand0ml0ok1ngstUfF1nh3re838hhsh36'

import access

# Catch SIGINT. sys.exit() would get ignored by this script,
# possibly having something to do with HTTP libraries' exception
# handling, so os._exit() is used instead.
def signal_handler(signal, frame):
	print "SIGINT caught, exiting. (PID: %d)" % (os.getpid())
#	tweet_output_file.close()
	username_file_desc.close()
	os._exit(0)
signal.signal(signal.SIGINT, signal_handler)


# parse command line arguments and display 
# a helpful tip if the user gets it wrong.
arg_count = 0
for arg in sys.argv:
	arg_count = arg_count + 1

if (arg_count == 2):
	username_file = sys.argv[1].strip()
else:
	username_file = "usernames.txt"

if (arg_count == 3):
	user_output_file = sys.argv[2].strip()
else:
	user_output_file = 0

if (arg_count == 0 or arg_count > 3):
	print "\nUsage: %s <username_file (optional)> <tweet_dump_file (optional)>" %(sys.argv[0])
	print "Default value for <username_file> is 'usernames.txt'"
	os._exit(1)


# Hardcoded keys specific to this set of applications (EgyptGraph)
# These should probably get shipped off somewhere else, maybe the access file.
CONSUMER_KEY = 'mJ6vPoSPrseFBsE2noKg'
CONSUMER_SECRET = 'oFxu6wKrWVLRvy2kHzVvPKpEhT9XuSrz6bcmcluDbw'


# Handshaking with Twitter using the account whose access keys were provided
auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
auth.set_access_token(access.ACCESS_KEY, access.ACCESS_SECRET)
api = tweepy.API(auth)

#set up output file if requested
if ( user_output_file != 0 ):
	try:
		tweet_output_file = codecs.open(user_output_file, encoding='utf-8', mode='w')
	except:
		print "Could not open specified output file to write, exiting."
		os._exit(1)

# attempt to set up to read from the username input file
try:	# username file descriptor
	username_file_desc = open(username_file, 'r')
except:
	print "Could not open username file, exiting."
	os._exit(1)

# the actual scanning of each user's status happens here.
for scan_target in username_file_desc:
	username = scan_target.strip()
	try:
		# pull down _one_ tweet. If you want more change the count arg.
		cur_user_status = api.user_timeline(username, count=1)
		cur_tweet = "%s says: %s" % (username, cur_user_status[0].text)

		# write to file is that argument was pessed, else print to screen.
		
		if ( user_output_file != 0 ):
			try:
				tweet_output_file.write(unicode(cur_tweet, encoding="utf-8"))
			except:
				print "Huh? Could not write to tweet output file."

		print cur_tweet

	except:
		print "Oops, %s's posts are unavailable." % (username)
	
	# this value was chosen to correspond to a maximum request rate of 350/hour
	# if 350 requests happen, twitter stops responding. Hence 11 second delay.
	time.sleep(1.0)



